
import Button from '@mui/material/Button';
import CssBaseline from '@mui/material/CssBaseline';
import TextField from '@mui/material/TextField';
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import Container from '@mui/material/Container';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import {toQrCode} from '@digitalbazaar/vpqr';
import { decodeSecretKeySeed, generateSecretKeySeed } from '@digitalcredentials/bnid';
import {driver} from '@digitalcredentials/did-method-key';
import {securityLoader} from '@digitalcredentials/security-document-loader';
import {issue, createPresentation} from '@digitalbazaar/vc';
import {Ed25519VerificationKey2020} from '@digitalbazaar/ed25519-verification-key-2020';
import {Ed25519Signature2020} from '@digitalbazaar/ed25519-signature-2020';
import { useState } from 'react';
import {v4 as uuidv4} from 'uuid';


import { composeOB3 } from './composeOB3.js';
import saveToGithub from './saveToGithub.js'
import defaultConfig from './defaultConfig.js';
import saveAsZip from './saveAsZip.js';

import './App.css';

const theme = createTheme();

function decodeSeed(secretKeySeed) {
  let secretKeySeedBytes // Uint8Array;
  if (secretKeySeed.startsWith('z')) {
  // This is a multibase-decoded key seed, like those generated by @digitalcredentials/did-cli
  secretKeySeedBytes = decodeSecretKeySeed({secretKeySeed});
  } else if (secretKeySeed.length >= 32) {
      secretKeySeedBytes = (new TextEncoder()).encode(secretKeySeed).slice(0, 32);
  } else {
  throw TypeError('"secretKeySeed" must be at least 32 bytes, preferably multibase-encoded.');
  }
  return secretKeySeedBytes;
}

const documentLoader = securityLoader().build()

async function buildSuite(didSeed) {
  const didKeyDriver = driver();
  const didSeedBytes = decodeSeed(didSeed);
  const { didDocument, methodFor } = await didKeyDriver.generate({ seed: didSeedBytes });
  const assertionMethod = methodFor({ purpose: 'assertionMethod' });
  const key = new Ed25519VerificationKey2020(assertionMethod);
  const suite = new Ed25519Signature2020({ key });
  const signingDID = didDocument.id;
  return { suite, signingDID };
}

// cache the suites
const suites = {}

async function getSuite(seed) {
    if (! suites[seed]) {
      suites[seed] = await buildSuite(seed)
    }
    return suites[seed]
}

async function sign(data, setData) {
  const config = data.config
  // if no default seed then generate a random one
  if (!config.seed) config.seed = await generateSecretKeySeed();
  const signedCreds = []
  const cborQRs = []
  for (let cred of data.creds) {
    const credData = {...config, ...cred} // combine defaults and individual cred data
    if (credData.credID === 'UUID') { 
      credData.credID = `urn:uuid:${uuidv4()}`
    } else if (credData.credID === 'GITHUB') {
      credData.credID = `https://raw.githubusercontent.com/${credData.githubOwner}/${credData.githubRepo}/main/${credData.fileName}`
    }
    const credential = composeOB3(credData)
    const {suite, signingDID} = await getSuite(credData.seed)
    credential.issuer.id = signingDID;
    try {
          const vc = await issue({
              credential,
              suite,
              documentLoader
          });
          signedCreds.push({vc,credData})
          const qrImage = await getQR(vc)
          if (qrImage) {
            cborQRs.push({qrImage,credData})
          }       
    } catch (e) {
          console.log("Error in the signing try block:")
          console.log(e)
    }
  }
  if (config.githubToken) {
    saveToGithub(config.githubToken, signedCreds, cborQRs)
  } else {
    saveAsZip(signedCreds, cborQRs)
  }
  setData(JSON.stringify(data, null, 3))
   
} 

async function getQR(verifiableCredential) {
  if (JSON.stringify(verifiableCredential).replace(/\s+/g, '').length < 4000) {
    const vp = await createPresentation({verifiableCredential});
    const {imageDataUrl} = await toQrCode({vp, documentLoader});
    let partToRemove = "data:image/gif;base64,"
    return imageDataUrl.slice(partToRemove.length)
  } 
  return null
}
 
function App() {
  const [config, setConfig] = useState(defaultConfig);
  const handleChange = (event) => {
    setConfig(event.target.value)
  }
  const handleClick = () => {
    const parsedConfig = JSON.parse(config)
    // we pass in the setConfig method so that we can update the 
    // data shown in the text area after signing:  in particular
    // we want to show the seed that was used for signing, if one
    // wasn't provided.
    sign(parsedConfig, setConfig)
  }
  
  return (
    <ThemeProvider theme={theme}>
    <Container component="main" maxWidth="m">
      <CssBaseline />
          <Typography component="h1" variant="h5">
            Generate some test credentials and save them to your Github repo.
          </Typography>
          <Box component="form" noValidate sx={{ mt: 1 }}>
            <TextField
              margin="normal"
              variant="outlined"
              required
              fullWidth
              id="config"
              value={config}
              onChange={handleChange}
              label="Credential Config"
              name="config"
              autoFocus
              multiline
              rows={20}
              rowsmax={100}
              placeholder="Might put a preset config here."
            />
          
            <Button
              onClick={handleClick}
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
            >
              Go! 
            </Button>
          </Box>
   
    </Container>
    </ThemeProvider>
  );
}

export default App;
